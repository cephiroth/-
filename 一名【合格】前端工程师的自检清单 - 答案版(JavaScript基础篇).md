## 契机
在这里看到了一篇蛮有意义的的文章,[一名【合格】前端工程师的自检清单](https://juejin.im/post/5cc1da82f265da036023b628).

看完之后感触颇深,觉得自己距离一名合格的前端工程师还有差距,于是自己尝试着对照着原作者自己整理的每一点,自己作了初步的解答,准备写成文章,做一个记录吧.

由于这份自检清单的点太多了,准备分很多期来做一个整理,如果有答得不好的点,欢迎大家指正,如果原文作者对于本文有任何问题,也欢迎指出,谢谢.

## 一、JavaScript基础

### 变量和类型

#### 1.`JavaScript`规定了几种语言类型

规定了7种语言类型: `null`、`undefined`、`String`、`Number`、`Boolean`、`Object`、`Symbol`,其中引用类型为`Object`,其余为基本类型.

#### 2.`JavaScript`对象的底层数据结构是什么

`Dictionary`,也就是字典

#### 3.`Symbol`类型在实际开发中的应用、可手动实现一个简单的`Symbol`

Symbol表示独一无二的值，它是一切非字符串的对象key的集合.`Symbol` 值通过`Symbol`函数生成.在实际开发中,经常用于定义常量或者定义私有属性.

在实现`Symbol`的时候,我发现`Symbol`很多特性都无法模拟,例如使用`typeof`,结果为"symbol",如果我们要模拟实现一个`Symbol`的话，基本的思路就是构建一个`Symbol`函数，然后直接返回一个独一无二的值.

#### 4.`JavaScript`中的变量在内存中的具体存储形式

基本类型是保存在栈内存中的简单数据段,它们的值都有固定的大小,保存在栈空间,通过按值访问.

引用类型是保存在堆内存中的对象,值大小不固定,栈内存中存放的该对象的访问地址指向堆内存中的对象,`JavaScript`不允许直接访问堆内存中的位置,因此操作对象时，实际操作对象的引用.

#### 5.基本类型对应的内置对象，以及他们之间的装箱拆箱操作

`String()`,`Number()`,`Boolean()`,`Symbol()`

装箱为new xxxx()，拆箱为`toString()`,`valueOf()`

#### 6.理解值类型和引用类型

值类型,也就是基本类型;

引用类型开辟堆内存,会给所有赋值的对象添加一个引用,指向一个地址,所以引用类型会出现一处修改,处处变化.

#### 7.`null`和`undefined`的区别

`undefined`为变量初始化没有赋具体的值,当声明的变量还未被初始化时,变量的默认值为`undefined`.

`null`表示为变量为空,或者对象为空,即不会占用内存,在清理内存占用可以使用`null`赋值.

```javascript
null == undefined; //true
null === undefined; //false
typeof undefined; // undefined
typeof null; //object
```

#### 8.至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型

1. `typeof`
* 对于基本类型,除`null`以外,均可以返回正确的结果;
* 对于引用类型,除`function`以外,一律返`object`类型;
* 对于`null`,返回`object`类型;
* 对于`function`返回`function`类型;

2. `instanceof `
`instanceof`只能用来判断两个对象是否属于实例关系,而不能判断一个对象实例具体属于哪种类型.

3. `constructor`

* `null`和`undefined`是无效的对象,因此是不会有`constructor`存在的,这两种类型的数据需要通过其他方式来判断;
* 函数的`constructor`是不稳定的,这个主要体现在自定义对象上,当开发者重写 `prototype`后,原有的`constructor`引用会丢失,`constructor`会默认为`Object`

4. `toString`
对于`Object`对象,直接调用`toString()`就能返回`[object Object]`;而对于其他对象,则需要通过`call`/`apply`来调用才能返回正确的类型信息.

准确的判断数组类型: `Array.isArray()`

#### 9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用
隐式类型转换的场景:
* 使用`if`作判断的时候
* 运算符的转换,例如在做`+`运算操作时,`1+'2' // '12'`
* 对象的转换

转换原则: 基本上大多数类型做隐式转换时都会调用`valueOf`和`toString`

如何避免:
* 在进行值比较时,使用`===`替代`==`;
* 尽量不要使用`+`运算符做字符串与数字的直接运算

应用:
* 在做`if`判断时可以直接使用`undefined`或者`null`与布尔值的转换、数字0和1与布尔值的转换以及空字符串与布尔值的转换
* 把字符串类型转换为数字

```javascript
let i = '1'
console.log(typeof(+i))
```

#### 10.出现小数精度丢失的原因，`JavaScript`可以存储的最大数字、最大安全数字，`JavaScript`处理大数字的方法、避免精度丢失的方法

* 小数精度丢失的原因:`Number`类型采用`IEEE754`标准中的“双精度浮点数”来表示一个数字,不区分整数和浮点数.
* 最大数字:`Number.MAX_VALUE; // 1.7976931348623157e+308`
* 最小数字:`Number.MIN_VALUE; // 5e-324`
* 最大安全数字:`Number.MAX_SAFE_INTEGER; // 9007199254740991`
* 最小安全数字:`Number.MIN_SAFE_INTEGER; // -9007199254740991`
* 处理大数字的方法:可以采用字符串进行存储和处理
* 避免精度丢失的方法:可以采用乘以10的倍数来扩大数字，再除以10的倍数，得到准确的数值,还有可以采用toFixed(0)


## 结语

变量和类型这一块的答案都写了这么多,后面的原型和原型链这些,可能就要花很大的篇幅来写答案了,不过我还是会坚持一直更新下去的,也是对自己的一个知识累积,加油吧!